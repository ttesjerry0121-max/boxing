import pygame
import random
import math
import sys

# --- 初始化設定 ---
pygame.init()
SCREEN_WIDTH = 900
SCREEN_HEIGHT = 600
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption("Cyberpunk Boxing: Python Final Fix")
clock = pygame.time.Clock()
FPS = 60

# --- 顏色定義 (RGB) ---
NEON_BLUE = (0, 255, 255)
NEON_RED = (255, 50, 80)
NEON_YELLOW = (255, 230, 0)
NEON_PURPLE = (180, 0, 255)
NEON_ORANGE = (255, 165, 0)
WHITE = (255, 255, 255)
BLACK = (5, 5, 16)  # 深色背景
GRAY = (100, 100, 100)
DARK_GRAY = (50, 50, 50)
UI_BG = (20, 20, 30)

# --- 遊戲數值 ---
MAX_HP = 100
MAX_EN = 8
DAMAGE = {'attack': 10, 'skill1': 20, 'skill2': 35, 'skill3': 60}

# --- 字型設定 ---
def get_font(size):
    font_names = ["microsoftjhenghei", "simhei", "arial"]
    for name in font_names:
        try:
            return pygame.font.SysFont(name, size, bold=True)
        except:
            continue
    return pygame.font.Font(None, size)

font_ui = get_font(20)
font_big = get_font(60)
font_dmg = get_font(30)

# --- 類別定義 ---

class Particle:
    def __init__(self, x, y, color):
        self.x = x
        self.y = y
        self.vx = random.uniform(-5, 5)
        self.vy = random.uniform(-5, 5)
        self.life = random.randint(20, 40)
        self.color = color
        self.size = random.randint(3, 6)

    def update(self):
        self.x += self.vx
        self.y += self.vy
        self.life -= 1
        self.size = max(0, self.size - 0.1)

    def draw(self, surface, offset_x, offset_y):
        if self.life > 0:
            pygame.draw.circle(surface, self.color, (int(self.x + offset_x), int(self.y + offset_y)), int(self.size))

class FloatingText:
    def __init__(self, text, x, y, color):
        self.text = str(text)
        self.x = x
        self.y = y
        self.vy = -2
        self.life = 60
        self.color = color
        self.surf = font_dmg.render(self.text, True, color)
        self.outline = font_dmg.render(self.text, True, (0,0,0))

    def update(self):
        self.y += self.vy
        self.vy *= 0.95
        self.life -= 1

    def draw(self, surface, offset_x, offset_y):
        if self.life > 0:
            x = self.x + offset_x - self.surf.get_width()//2
            y = self.y + offset_y
            for dx, dy in [(-2,0), (2,0), (0,-2), (0,2)]:
                surface.blit(self.outline, (x+dx, y+dy))
            surface.blit(self.surf, (x, y))

class Fighter:
    def __init__(self, is_player):
        self.is_player = is_player
        self.reset()

    def reset(self):
        self.hp = MAX_HP
        self.energy = 0
        self.state = "idle"
        self.x = 250 if self.is_player else 650
        self.y = 350
        self.shake = 0
        self.flash_timer = 0

    def take_damage(self, amount):
        self.hp -= amount
        self.flash_timer = 5
        self.shake = 20
        create_particles(self.x, self.y - 100, NEON_RED if self.is_player else NEON_BLUE)
        create_text(f"-{amount}", self.x, self.y - 150, NEON_RED)

    def draw(self, surface, ox, oy):
        dx = self.x + random.randint(-int(self.shake), int(self.shake)) + ox
        dy = self.y + oy
        base_color = NEON_BLUE if self.is_player else NEON_RED
        color = WHITE if self.flash_timer > 0 else base_color
        if self.flash_timer > 0: self.flash_timer -= 1
        
        breath = math.sin(pygame.time.get_ticks() / 300) * 2
        facing = 1 if self.is_player else -1
        
        def t(lx, ly): return (dx + lx * facing, dy + ly)

        # 1. 腿部
        if self.state == "charge": 
            pts_legs = [(-20, 0), (-10, -40), (0, -60), (10, -40), (20, 0)]
        else: 
            pts_legs = [(-20, 0), (-10, -50), (0, -80 + breath), (10, -50), (20, 0)]
        pygame.draw.lines(surface, color, False, [t(*p) for p in pts_legs], 4)

        # 2. 身體
        if self.state == "charge": pts_body = [(0, -60), (10, -110)]
        elif self.state == "attack": pts_body = [(0, -80 + breath), (20, -130 + breath)]
        else: pts_body = [(0, -80 + breath), (0, -130 + breath)]
        pygame.draw.lines(surface, color, False, [t(*p) for p in pts_body], 4)

        # 3. 頭部
        hx, hy = 0, -145 + breath
        if self.state == "charge": hx, hy = 15, -125
        if self.state == "attack": hx, hy = 25, -145 + breath
        head_pos = t(hx, hy)
        pygame.draw.circle(surface, color, (int(head_pos[0]), int(head_pos[1])), 12, 2)
        eye_pos = t(hx + 6, hy - 2)
        pygame.draw.circle(surface, WHITE, (int(eye_pos[0]), int(eye_pos[1])), 2)

        # 4. 手臂
        if self.state == "idle": pts_arm = [(0, -120+breath), (15, -100+breath), (25, -125+breath)]
        elif self.state in ["block", "s_block"]: pts_arm = [(0, -120+breath), (20, -110+breath), (20, -140+breath)]
        elif self.state == "charge": pts_arm = [(10, -100), (30, -90), (10, -70)]
        elif self.state == "attack": pts_arm = [(0, -120+breath), (40, -120+breath), (80, -120+breath)]
        else: pts_arm = [(0, -120+breath), (15, -100+breath), (25, -125+breath)]
        pygame.draw.lines(surface, color, False, [t(*p) for p in pts_arm], 4)

        # 特效
        if self.state == "attack":
            fist_pos = t(85, -120 + breath)
            pygame.draw.circle(surface, WHITE, (int(fist_pos[0]), int(fist_pos[1])), 8)
        elif self.state == "block":
            real_x = dx + 40 if facing == 1 else dx - 40 - 10
            s_rect = pygame.Rect(real_x, dy - 160, 10, 160)
            s_surf = pygame.Surface((10, 160), pygame.SRCALPHA)
            s_surf.fill((*NEON_BLUE, 100)) 
            surface.blit(s_surf, s_rect)
            pygame.draw.rect(surface, NEON_BLUE, s_rect, 2)
        elif self.state == "s_block":
            center = t(0, -80)
            pygame.draw.circle(surface, NEON_PURPLE, (int(center[0]), int(center[1])), 70, 4)
        elif self.state == "charge":
            center = t(10, -60)
            pygame.draw.circle(surface, NEON_YELLOW, (int(center[0]), int(center[1])), 50, 2)

        if self.shake > 0: self.shake *= 0.8
        if self.shake < 0.5: self.shake = 0

class Button:
    def __init__(self, text, x, y, color, action, cost=0):
        self.rect = pygame.Rect(x, y, 100, 50)
        self.text = text
        self.color = color
        self.action = action
        self.cost = cost

    def draw(self, surface, energy, active):
        disabled = energy < self.cost or not active
        is_hover = self.rect.collidepoint(pygame.mouse.get_pos())
        
        if not disabled and is_hover:
            pygame.draw.rect(surface, WHITE, self.rect.inflate(4, 4))
            
        col = GRAY if disabled else self.color
        pygame.draw.rect(surface, col, self.rect)
        pygame.draw.rect(surface, WHITE, self.rect, 2)
        
        txt_col = BLACK if not disabled else WHITE
        txt_surf = font_ui.render(self.text, True, txt_col)
        surface.blit(txt_surf, (self.rect.centerx - txt_surf.get_width()//2, self.rect.centery - txt_surf.get_height()//2))
        
        if self.cost > 0:
            cost_surf = font_ui.render(f"氣{self.cost}", True, WHITE)
            surface.blit(cost_surf, (self.rect.right - 35, self.rect.bottom - 20))

    def is_clicked(self, pos, energy):
        return self.rect.collidepoint(pos) and energy >= self.cost

# --- 全域變數 ---
player = Fighter(True)
cpu = Fighter(False)
particles = []
floating_texts = []
screen_shake = 0

btns = [
    Button("集氣", 40, 450, NEON_YELLOW, "charge"),
    Button("防禦", 150, 450, NEON_BLUE, "block"),
    Button("超級防守", 260, 450, NEON_PURPLE, "s_block"),
    Button("機械刺拳", 370, 450, NEON_RED, "attack"),
    Button("音速衝擊", 480, 450, NEON_ORANGE, "skill1", 1),
    Button("雷霆重擊", 590, 450, (255, 100, 0), "skill2", 2),
    Button("終極崩壞", 700, 450, (255, 0, 0), "skill3", 3),
]

# 投降按鈕
btn_surrender = Button("投降", 800, 10, NEON_RED, "surrender")
btn_surrender.rect.width = 80 

def create_particles(x, y, color):
    for _ in range(10): particles.append(Particle(x, y, color))

def create_text(text, x, y, color):
    floating_texts.append(FloatingText(text, x, y, color))

def draw_hud(surface, x, y, hp, en, color, name):
    name_txt = font_ui.render(name, True, color)
    surface.blit(name_txt, (x, y))
    bar_rect = pygame.Rect(x, y+25, 220, 20)
    pygame.draw.rect(surface, DARK_GRAY, bar_rect)
    if hp > 0:
        fill_width = 220 * (hp / MAX_HP)
        pygame.draw.rect(surface, color, (x, y+25, fill_width, 20))
    pygame.draw.rect(surface, WHITE, bar_rect, 2)
    val_txt = font_ui.render(f"{int(hp)}/{MAX_HP}", True, WHITE)
    surface.blit(val_txt, (x + 110 - val_txt.get_width()//2, y + 25))
    for i in range(MAX_EN):
        c = NEON_YELLOW if i < en else DARK_GRAY
        cx = x + 15 + i * 27
        cy = y + 65
        pygame.draw.circle(surface, c, (cx, cy), 8)
        pygame.draw.circle(surface, BLACK, (cx, cy), 8, 1)

def main():
    global screen_shake
    running = True
    state = "INPUT" 
    timer = 0
    p_act = None
    c_act = None
    log_msg = "請選擇行動"
    winner = ""

    while running:
        # 震動計算
        ox, oy = 0, 0
        if screen_shake > 0:
            ox = random.uniform(-screen_shake, screen_shake)
            oy = random.uniform(-screen_shake, screen_shake)
            screen_shake *= 0.9
            if screen_shake < 0.5: screen_shake = 0

        for p in particles[:]:
            p.update()
            if p.life <= 0: particles.remove(p)
        for t in floating_texts[:]:
            t.update()
            if t.life <= 0: floating_texts.remove(t)

        # 狀態機
        if state == "ANIM":
            timer += 1
            if timer > 40:
                # 結算
                dmg_p = 0
                dmg_c = 0
                
                # 玩家打電腦
                if p_act in ["attack", "skill1", "skill2", "skill3"]:
                    base = DAMAGE.get(p_act, 10)
                    blocked = False
                    if p_act == "skill3": 
                        if c_act == "s_block": blocked = True
                    else:
                        if c_act == "block": blocked = True
                    
                    if blocked: create_text("格擋!", cpu.x, cpu.y-120, NEON_BLUE)
                    else:
                        cpu.take_damage(base)
                        screen_shake += 10 if base > 20 else 5
                
                # 電腦打玩家
                if c_act in ["attack", "skill1", "skill2", "skill3"]:
                    base = DAMAGE.get(c_act, 10)
                    blocked = False
                    if c_act == "skill3":
                        if p_act == "s_block": blocked = True
                    else:
                        if p_act == "block": blocked = True
                    
                    if blocked: create_text("格擋!", player.x, player.y-120, NEON_BLUE)
                    else:
                        player.take_damage(base)
                        screen_shake += 10 if base > 20 else 5

                # 集氣
                if p_act == "charge" and player.hp > 0:
                    interrupted = c_act in ["skill1", "skill2", "skill3"]
                    if interrupted: create_text("中斷!", player.x, player.y - 100, GRAY)
                    else:
                        if c_act == "attack": create_text("硬扛!", player.x, player.y - 100, NEON_ORANGE)
                        player.energy = min(MAX_EN, player.energy + 1)
                        create_text("+1氣", player.x, player.y - 120, NEON_YELLOW)

                if c_act == "charge" and cpu.hp > 0:
                    interrupted = p_act in ["skill1", "skill2", "skill3"]
                    if interrupted: create_text("中斷!", cpu.x, cpu.y - 100, GRAY)
                    else:
                        if p_act == "attack": create_text("硬扛!", cpu.x, cpu.y - 100, NEON_ORANGE)
                        cpu.energy = min(MAX_EN, cpu.energy + 1)
                        create_text("+1氣", cpu.x, cpu.y - 120, NEON_YELLOW)

                state = "RESOLVE"
                timer = 0

        elif state == "RESOLVE":
            timer += 1
            # 等待一秒看結果
            if timer > 60:
                player.state = "idle"
                cpu.state = "idle"
                
                if player.hp <= 0 or cpu.hp <= 0:
                    state = "GAMEOVER"
                    if player.hp > 0: winner = "你贏了！"
                    elif cpu.hp > 0: winner = "你輸了！"
                    else: winner = "平手！"
                else:
                    state = "INPUT"
                    log_msg = "下一回合"

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            
            if event.type == pygame.MOUSEBUTTONDOWN:
                if state == "INPUT":
                    # [修復] 投降邏輯：直接跳過動畫，設為 RESOLVE 狀態，並把 timer 設為 61 (大於 60)
                    # 這樣下一幀就會直接觸發 RESOLVE 的結束條件，進入 GAMEOVER
                    if btn_surrender.is_clicked(event.pos, 999):
                        player.hp = 0
                        state = "RESOLVE" 
                        timer = 61  # 關鍵：直接觸發下個狀態
                        p_act = "idle"
                        c_act = "idle"
                        log_msg = "你投降了..."
                    
                    else:
                        for btn in btns:
                            if btn.is_clicked(event.pos, player.energy):
                                p_act = btn.action
                                
                                # AI
                                opts = ["attack", "block"]
                                if cpu.energy >= 1: opts.append("skill1")
                                if cpu.energy >= 2: opts.append("skill2")
                                if cpu.energy >= 3: opts.append("skill3")
                                if cpu.energy == 0: opts.append("charge")
                                
                                c_act = None
                                if cpu.hp < 30 and cpu.energy < 2 and random.random() < 0.6: c_act = "block"
                                if not c_act and player.energy >= 3 and random.random() < 0.35: c_act = "s_block"
                                if not c_act and cpu.energy >= 3 and random.random() < 0.65: c_act = "skill3"
                                if not c_act: c_act = random.choice(opts)

                                def get_cost(act):
                                    if act == "skill1": return 1
                                    if act == "skill2": return 2
                                    if act == "skill3": return 3
                                    return 0
                                
                                player.energy -= get_cost(p_act)
                                cpu.energy -= get_cost(c_act)

                                def set_vis(fighter, act):
                                    if act == "charge": fighter.state = "charge"
                                    elif act == "block": fighter.state = "block"
                                    elif act == "s_block": fighter.state = "s_block"
                                    elif act in ["attack", "skill1", "skill2", "skill3"]: fighter.state = "attack"
                                    else: fighter.state = "idle"
                                
                                set_vis(player, p_act)
                                set_vis(cpu, c_act)

                                state = "ANIM"
                                timer = 0
                                log_msg = "交鋒！"
                                break
                            
                elif state == "GAMEOVER":
                    player.reset()
                    cpu.reset()
                    particles.clear()
                    floating_texts.clear()
                    state = "INPUT"
                    log_msg = "新戰鬥開始"

        screen.fill(BLACK)
        for x in range(-200, 1100, 50):
            pygame.draw.line(screen, (40, 0, 60), (x + ox * 0.5, 400 + oy), (x - 300 + (x/900)*600 + ox, 600 + oy))
        pygame.draw.line(screen, (200, 0, 200), (0, 400 + oy), (900, 400 + oy), 3)

        player.draw(screen, ox, oy)
        cpu.draw(screen, ox, oy)

        for p in particles: p.draw(screen, ox, oy)
        for t in floating_texts: t.draw(screen, ox, oy)

        if state == "INPUT":
            pygame.draw.rect(screen, UI_BG, (0, 430, 900, 170))
            pygame.draw.line(screen, NEON_BLUE, (0, 430), (900, 430), 2)
            for btn in btns: btn.draw(screen, player.energy, True)
            btn_surrender.draw(screen, 999, True)

        elif state == "GAMEOVER":
            overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
            overlay.set_alpha(200)
            overlay.fill(BLACK)
            screen.blit(overlay, (0,0))
            
            res_txt = font_big.render(winner, True, NEON_BLUE if "贏" in winner else NEON_RED)
            screen.blit(res_txt, (SCREEN_WIDTH//2 - res_txt.get_width()//2, 250))
            hint = font_ui.render("點擊任意處重新開始", True, WHITE)
            screen.blit(hint, (SCREEN_WIDTH//2 - hint.get_width()//2, 350))

        draw_hud(screen, 20, 20, player.hp, player.energy, NEON_BLUE, "PLAYER")
        draw_hud(screen, 660, 20, cpu.hp, cpu.energy, NEON_RED, "CPU")
        
        msg_surf = font_ui.render(log_msg, True, WHITE)
        screen.blit(msg_surf, (SCREEN_WIDTH//2 - msg_surf.get_width()//2, 80))

        pygame.display.flip()
        clock.tick(FPS)

    pygame.quit()
    sys.exit()

if __name__ == "__main__":
    main()
